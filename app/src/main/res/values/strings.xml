<resources>
    <string name="app_name">JavaAndroidSummary</string>
    <string name="teoriaString">Обобщенные(generics) или параметризированные типы — классы, которые компилятор автоматически адаптирует для работы с определенными типами.  ArrayList &lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;\n
Места хранения данных:\n *** \n
Регистры — данные хранятся в процессоре (в Java недоступно)\n
Стек — данные хранятся в RAM, доступ с помощью указателя стека. Компилятор должен знать время жизни данных. В Java хранятся только вспомогательные данные(ссылки на объекты, примитивные типы), но не объекты./n
Куча — пул памяти общего назначения в RAM.\n
Постоянное хранилище — константы в коде или ROM на встроенных системах.\n
Внешнее хранилище — потоки, файлы на диске. </string>
    <string name="primitiveTypesString">
            BigInteger — целое число для операций повышенной точности\n
            BigDecimal — число с фиксированной запятой для операций повышенной точности\n
    </string>
    <string name="BazovyeVeschi">
        Объявление класса:  class имя{}\n
        Создание объекта имяКласса имяОбъекта = new имяКласса();\n
        Объявление метода: возвращаемыйТип ИмяМетода(список аргументов){тело метода}\n
        Вызов метода объекта: имяОбъекта.имяМетода(значения аргументов) \n
        Доступ к полю класса:   имяОбъекта.переменная\n
        Метод возвращает значение с помощью return. Если нет то возвращаемый тип void\n
        Static — данные или методы не привязаны к определенному экземпляру класса.
        Для них не существует ссылки this. Можно вызывать, даже если не создано ни о
        дного объекта:\n имяКласса.статическиеДанные
    </string>
    <string name="BiblObjMethString">
        Создание генератора начальных значений:\n
        Random "объект" = new Random("начальное число") \nС начальным числом результаты предсказуемые.
        \n\nМетод  генерации случайного  числа int:\n
        "объект".nextInt("верхнее значение") + "добавить к результату до нижнего значения"\n
         Так же методы nextLong(), nextFloat(), nextDouble().\n\n
        Сравнение содержимого объектов equals: \n
        n1.equals(n2)\n\n
        Округление: \n
        Math.round(значение)
    </string>
    <string name="LiteratoryString">
        int i1 = 0x2f шестнадцатиричное, нижний регистр\n
        int i2 = 0x2F шестнадцатиричное, верхний регистр\n
        int i3 = 0177 восьмиричное\n
        char c = 0xfff  максимальное шестнадцатиричное значение char\n
        byte b = 0x7f  максимальное шестнадцатиричное значение byte\n
        short s = 0x7f  максимальное шестнадцатиричное значение short\n
        long l1 = 1l или 1L\n
        float f1 = 1f или 1F\n
        double d1 = 1d или 1D\n
        1.39e-43f == 1.39x10\u207B\u2074\u2075  экспоненциальная запись
    </string>
    <string name="operator1">
        a = b присваивание\n\n
        Синонимия - объект присваивается другому объекту того же класса, они оба становятся
        ссылками на один объект (значения меняются синхронно)
    </string>
    <string name="operator2">
        + плюс,  - минус, * умножить,  / деление нацело с усечением, % остаток от деления.\n
        операция с присвоением (x+=y)==(x=x+y) и т. д.\n
        унитарные минус и плюс -a  +a\n
        Автоувеличение и автоуменьшение i++ i-- (постфиксная — сначала выдается исходное
        значение, потом результат),  ++i  --i (префиксная сразу результат)
    </string>
    <string name="operator3">
        "меньше чем" &lt; , "больше чем" &gt; , "меньше чем или равно" &lt;= ,
        "больше чем или равно" &gt;= , "равно" ==, "не равно" !=. Для boolean только два последних.\n
        Если сравниваются объекты, сравниваются ссылки а не содержимое: Integer n1 =47; Integer n2 = 47; i != x;
        так как это ссылки на разные объекты. Для сравнения содержимого объектов использовать метод equals()
    </string>
    <string name="operator4">
        могут использовать ускоренное вычисление (не вычислять операторы, от которых не зависит конечный результат)
        &amp;&amp; И true если оба аргумента true
        || ИЛИ true если один из аргументов true
        ! НЕ меняет результат на противоположный
    </string>
    <string name="operator5">
        манипулируют битами в целочисленных примитивных типах данных\n
        &amp; И 1 если оба бита 1\n
        | ИЛИ 1 если один из битов 1\n
        ^ XOR исключающее или 1 если один бит 1 а другой 0\n
        ~ НЕ  меняет бит на противоположный\n
        &amp;=  |=  ^=   сравнивание с присваиванием\n
    </string>
    <string name="operator6">
        манипулируют битами в целочисленных примитивных типах данных\n
        &gt;&gt; оператор сдвига вправо сдвигает вправо операунд находящийся слева от оператора на количество битов, указанных после оператора\n
        &lt;&lt; оператор сдвига вправо сдвигает влево операунд находящийся слева от оператора на количество битов, указанных после оператора\n
        &lt;&lt; и &gt;&gt;  осуществляют заполнение знаком — при положительном значении биты заполняются единицами, при отрицательном нулями\n
        &gt;&gt;&gt; беззнаковый  сдвиг вправо — биты заполняются нулями\n
        &lt;&lt;=   &gt;&gt; =  сдвиг с присваиванием. &gt;&gt;&gt;= результат некорректный\n
    </string>
    <string name="operator7">
        (int)значение    (long)значение    (float)значение   (double)значение  - приводят значение к соответствующему типу.
    </string>
    <string name="operator8">
        + и += для String  объединяют строки
    </string>
    <string name="operator9">
        условие   ? выражение1 : выражение2\n   если условие=true, то выполняется выражение1, если false, то выполняется выражение2.
    </string>
    <string name="UprKonstrukcii1">
        if else
    </string>
    <string name="UprKonstrukcii2">
        if (условие)\n
        else if(условие)\n
        else
    </string>
    <string name="UprKonstrukcii3">
        switch
    </string>
    <string name="UprKonstrukcii4">
        switch(i)  //объявляем переменную\n
        case 1: команда; break; //первое значение\n
        case 2: команда; break; //второе значение\n
            //...\n
        default: команда: //для неопределенных значений\n
        Если нет команды break, выполняется следующая команда
    </string>
    <string name="UprKonstrukcii5">
        Циклы
    </string>
    <string name="UprKonstrukcii6">
        for(инициализация; логическое выражение; шаг){команды}\n
        выполняется пока логическое выражение верно.\n\n
        Оператор запятая позволяет определить несколько переменных и управляющих выражений, но только
        одного типа. for(int i =1, j =i +10; i &lt; 5; i++, j = i *2)\n\n
        while(логическое выражение){команды}  выполняется если логическое выражение true\n\n
        do{команды}while(логическое выражение) выполняется один раз, если логическое выражение true,
        повторяет цикл
    </string>
    <string name="TextView1">
        Создание в layout:\n
        &lt;TextView\n
        android:layout_width="wrap_content"\n
        android:layout_height="wrap_content"\n
        android:text="текст"  // или ссылка на ресурс string @string/имя string\n
        >/
    </string>
    <string name="TextView2">
        Создание в активности:\n
        LinearLayout linearLayout = new LinearLayout(this);\n
        TextView textView1 = new TextView(this);\n
        textView1.setText("текст или ссылка на ресурс");\n
        textView1.setLayoutParams(layoutParams);\n
        linearLayout.addView(textView1);\n
        setContentView(linearLayout);\n
    </string>
    <string name="AdaptersAndLists1">
        Списки являются наследниками класса android.widget.AdapterView
    </string>
    <string name="ListView1">
        Представление массива переменных в виде списка\n
        Варианты создания:\n
    </string>
    <string name="ListView2">
                LAYOUT\n
        &lt;ListView\n
            android:id="@+id/nameList" \\определяем ListView\n
            android:entries="@+id/nameMassive" \\ ссылка на ресурс массива\n
        />\n
                VALUES\n
        &lt;string-array name="@array/nameMassive">\n
            &lt;item>item1&lt;/item>\n
            &lt;item>item2&lt;/item>\n
            &lt;item>item3&lt;/item>\n
        &lt;/string-array>\n
    </string>
    <string name="ListView3">
                2. Размещение массива в коде\n
        LAYOUT\n
        &lt;ListView\n
            android:id="@+id/nameList" \\определяем ListView\n
        />\n

        В активности:\n
        String[] nameMassive = { "item1", "item2", "item3"};\n
        ListView имя = (ListView) findViewById(R.id.nameList);  //получаем элемент ListView из файла разметки\n
        ArrayAdapter&lt;String> adapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, countries); // создаем адаптер и подключаем массив\n
        имя.setAdapter(adapter);
    </string>
    <string name="resurs">
        Обращение к ресурсам из активности:\n
        String application_name =  getResources().getString(R.string.app_name);\n
        Массив строк:\n
        &lt;string-array name="Имя">\n
            &lt;item>имя&lt;/item>\n
        ...\n
        &lt;/string-array>\n
    </string>
    <string name="PerDanActAr">
        Для передачи данных применяется метод putExtra(), который в качестве значения позволяет передать
        данные простейших типов - String, int, float, double, long, short, byte, char, массивы этих типов, либо объект интерфейса Serializable:\n
        intent.putExtra("ключ", значение);\n
        Чтобы получить отправленные данные при загрузке SecondActivity, можно воспользоваться методом get(), в который передается ключ объекта:\n
        Bundle ИмяОбъектаBundle = getIntent().getExtras();\n
        переменная = ИмяОбъектаBundle.get("ключ")
    </string>
    <string name="gitOsnova">
        .git/config файл настройки с секциями [core], [user] и .т.д. подсекциями [diff "png']\n
        уровни настроек --global (в домашней директории) --system  --local\n
        git config user.name "имя пользователя"\n
        git config user.email "почта"\n
        git config --list  вывести все настройки\n
        git config --unset удалить параметр\n
        git config --remove-section удалить определенную секцию\n
        get help команда \n
        git config --edit  или -e открыть файл настроек в редакторе\n
        git config --global core.editor настройка редактора для файлов настроек\n
        git config --global alias.c config  назначить автозамену "config" на "с"\n
        … alias.c '!команда1; команда2;'     автозамена "c" на несколько команд\n
        git config include.path   подключить доп. файл настроек, --add добавить не затирая старую настройку
    </string>
    <string name="TypesFiles">
        core.autocrlf настройка переноса строки в текстовых файлах. True — Windows (файл сохраняется в юникс-кодировке, при открытии переводится в Windows кодировку), input — Unix ( файл сохраняется и открывается в юникс-кодировке), false — не менять кодировку\n
        &lt;project>/.gitattributes или &lt;project>/.git/info/attrebutes /etc/gitattributes правила по которым гит определяет типы файлов\n
        *text =auto  git определяет тип файла по содержимому\n
        *.html text     текстовый файл\n
        *.gif -text     или .gif  binary бинарный\n
        *sln text eol=crlf   настройка переноса строк\n
        git help attributes справка\n
    </string>
    <string name="gitIgnore">
        Папки и директории, которые git игнорирует. .gitignore читается последовательно\n
        .DS_Store\n
        *.log шаблон\n
        *.py[co]   это *.pyc или *.pyo\n
        migrate-201[5-7]  это migrate-2015  migrate-2016 migrate-2017\n
        ?  один произвольный символ\n
        * множество символов, но не слеш\n
        /*/ любая вложенная папка\n
        /**/ несколько втожений\n
        ! отменяет исключение\n
        build/  любая папка build в проекте\n
        Если слеш находтся не в конце шаблон читается как основной путь от места расположения .gitignore\n
        /build/    папка в корне\n
        secret/key  или /secret/key путь от корня\n
        doc/*.html файлы в директории doc которая в корне\n
        Не работает, так как git не узнает о существовании файла packages.xml:\n
        /install/\n
        !install/packages.xml\n
        Правильно\n
        /install/*\n
        !install/packages.xml\n
        git check-ignore - v путь     проверка исключений\n
        Возможные местоположения исключений\n
        &lt;project>/.../.gitignore\n
        &lt;project>/.git/infj/excludes\n
        config: core.exludeFile\n
    </string>
    <string name="SozdRepCom">
        Рабочая директория, index — список файлов отслеживаемых git и промежуточное хранилище, репазиторий \n
        git init создает папку .git\n
        git status информация о статусе файлов проекта\n
        git add файл    проиндексировать файл. git add .   добавить все. -f добавить игнорируемый файл. -p спрашивать про каждое изменение\n
        git commit закоммитить проиндексированные файлы (--author=\u0027имя &lt;email>\u0027  отдельно указать автора  --date авторская дата)\n
        git show посмотреть текущий коммит\n
        git reset HEAD файл     отменить индексацию\n
        Закачать коммит на github:\n
        git remote add origin https://github.com/.../*.git\n
        git push -u origin master
    </string>
    <string name="InitAndFinish">
        Конструктор — метод инициализации объекта. Имя конструктора совпадает с именем класса. \n
        new класс() сразу запускает конструктор\n
        Конструктор без аргументов — конструктор по умолчанию.\n
        Передача аргумента конструктору: класс объект = new класс(аргументы)\n
    </string>
    <string name="Peregruzka_metodov">
        Можно иметь в классе несколько конструкторов, которые будут различаться по типу аргументов
    </string>
    <string name="This">
        Ссылка на текущий объект. Может использоваться в связке с командой return для возврата
        ссылки на объект. Может использоваться для ссылки на текущий объект в методе, внешнем по
        отношению  к объекту. (стр 153 Философия Java)\n
        При вызове одного конструктора из другого this(аргументы) вызывает конструктор с
        соответствующими аргументами. Вызвать таким способом можно только один конструктор и
        вызов должен быть первой исполняемой операцией.\n
        Ссылка на поле данных класса: this.поле\n
    </string>
    <string name="finalize">
        Finalize() - метод, запускаемый уборщиком мусора перед  стиранием объекта. Определяется в
        теле класса. Может использоваться для проверки условия готовности объекта — можно ли стирать
        объект, все ли его части должным образом закрыты (стр161 Философия Java).
    </string>
</resources>
