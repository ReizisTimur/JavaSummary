<resources>
    <string name="app_name">JavaAndroidSummary</string>
    <string name="teoriaString">Обобщенные(generics) или параметризированные типы — классы, которые компилятор автоматически адаптирует для работы с определенными типами.  ArrayList &lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;\n
Места хранения данных:\n *** \n
Регистры — данные хранятся в процессоре (в Java недоступно)\n
Стек — данные хранятся в RAM, доступ с помощью указателя стека. Компилятор должен знать время жизни данных. В Java хранятся только вспомогательные данные(ссылки на объекты, примитивные типы), но не объекты./n
Куча — пул памяти общего назначения в RAM.\n
Постоянное хранилище — константы в коде или ROM на встроенных системах.\n
Внешнее хранилище — потоки, файлы на диске. </string>
    <string name="primitiveTypesString">
            BigInteger — целое число для операций повышенной точности\n
            BigDecimal — число с фиксированной запятой для операций повышенной точности\n
    </string>
    <string name="sintClMeString">
        Объявление метода:\n
        возвращаемыйТип ИмяМетода(список аргументов){тело метода}\n\n
        Вызов метода объекта:\n
        имяОбъекта.имяМетода(значения аргументов)\n\n
        Доступ к полю класса: \n
        имяОбъекта.переменная\n\n
        Метод возвращает значение с помощью return. Если нет то возвращаемый тип void \n\n
        Static — данные или методы не привязаны к определенному экземпляру класса. Можно вызывать, даже если не создано ни одного объекта:\n
        имяКласса.статическиеДанные
    </string>
    <string name="BiblObjMethString">
        Создание генератора начальных значений:\n
        Random "объект" = new Random("начальное число") \nС начальным числом результаты предсказуемые.
        \n\nМетод  генерации случайного  числа int:\n
        "объект".nextInt("верхнее значение") + "добавить к результату до нижнего значения"\n
         Так же методы nextLong(), nextFloat(), nextDouble().\n\n
        Сравнение содержимого объектов equals: \n
        n1.equals(n2)\n\n
        Округление: \n
        Math.round(значение)
    </string>
    <string name="LiteratoryString">
        int i1 = 0x2f шестнадцатиричное, нижний регистр\n
        int i2 = 0x2F шестнадцатиричное, верхний регистр\n
        int i3 = 0177 восьмиричное\n
        char c = 0xfff  максимальное шестнадцатиричное значение char\n
        byte b = 0x7f  максимальное шестнадцатиричное значение byte\n
        short s = 0x7f  максимальное шестнадцатиричное значение short\n
        long l1 = 1l или 1L\n
        float f1 = 1f или 1F\n
        double d1 = 1d или 1D\n
        1.39e-43f == 1.39x10\u207B\u2074\u2075  экспоненциальная запись
    </string>
    <string name="operator1">
        a = b присваивание\n\n
        Синонимия - объект присваивается другому объекту того же класса, они оба становятся
        ссылками на один объект (значения меняются синхронно)
    </string>
    <string name="operator2">
        + плюс,  - минус, * умножить,  / деление нацело с усечением, % остаток от деления.\n
        операция с присвоением (x+=y)==(x=x+y) и т. д.\n
        унитарные минус и плюс -a  +a\n
        Автоувеличение и автоуменьшение i++ i-- (постфиксная — сначала выдается исходное
        значение, потом результат),  ++i  --i (префиксная сразу результат)
    </string>
    <string name="operator3">
        "меньше чем" &lt; , "больше чем" &gt; , "меньше чем или равно" &lt;= ,
        "больше чем или равно" &gt;= , "равно" ==, "не равно" !=. Для boolean только два последних.\n
        Если сравниваются объекты, сравниваются ссылки а не содержимое: Integer n1 =47; Integer n2 = 47; i != x;
        так как это ссылки на разные объекты. Для сравнения содержимого объектов использовать метод equals()
    </string>
    <string name="operator4">
        могут использовать ускоренное вычисление (не вычислять операторы, от которых не зависит конечный результат)
        &amp;&amp; И true если оба аргумента true
        || ИЛИ true если один из аргументов true
        ! НЕ меняет результат на противоположный
    </string>
    <string name="operator5">
        манипулируют битами в целочисленных примитивных типах данных\n
        &amp; И 1 если оба бита 1\n
        | ИЛИ 1 если один из битов 1\n
        ^ XOR исключающее или 1 если один бит 1 а другой 0\n
        ~ НЕ  меняет бит на противоположный\n
        &amp;=  |=  ^=   сравнивание с присваиванием\n
    </string>
    <string name="operator6">
        манипулируют битами в целочисленных примитивных типах данных\n
        &gt;&gt; оператор сдвига вправо сдвигает вправо операунд находящийся слева от оператора на количество битов, указанных после оператора\n
        &lt;&lt; оператор сдвига вправо сдвигает влево операунд находящийся слева от оператора на количество битов, указанных после оператора\n
        &lt;&lt; и &gt;&gt;  осуществляют заполнение знаком — при положительном значении биты заполняются единицами, при отрицательном нулями\n
        &gt;&gt;&gt; беззнаковый  сдвиг вправо — биты заполняются нулями\n
        &lt;&lt;=   &gt;&gt; =  сдвиг с присваиванием. &gt;&gt;&gt;= результат некорректный\n
    </string>
    <string name="operator7">
        (int)значение    (long)значение    (float)значение   (double)значение  - приводят значение к соответствующему типу.
    </string>
    <string name="operator8">
        + и += для String  объединяют строки
    </string>
    <string name="operator9">
        условие   ? выражение1 : выражение2\n   если условие=true, то выполняется выражение1, если false, то выполняется выражение2.
    </string>
    <string name="UprKonstrukcii1">
        if else
    </string>
    <string name="UprKonstrukcii2">
        if (условие)\n
        else if(условие)\n
        else
    </string>
    <string name="UprKonstrukcii3">
        switch
    </string>
    <string name="UprKonstrukcii4">
        switch(i)  //объявляем переменную\n
        case 1: команда; break; //первое значение\n
        case 2: команда; break; //второе значение\n
            //...\n
        default: команда: //для неопределенных значений\n
        Если нет команды break, выполняется следующая команда
    </string>
    <string name="UprKonstrukcii5">
        Циклы
    </string>
    <string name="UprKonstrukcii6">
        for(инициализация; логическое выражение; шаг){команды}\n
        выполняется пока логическое выражение верно.\n\n
        Оператор запятая позволяет определить несколько переменных и управляющих выражений, но только
        одного типа. for(int i =1, j =i +10; i &lt; 5; i++, j = i *2)\n\n
        while(логическое выражение){команды}  выполняется если логическое выражение true\n\n
        do{команды}while(логическое выражение) выполняется один раз, если логическое выражение true,
        повторяет цикл
    </string>

</resources>
